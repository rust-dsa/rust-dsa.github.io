<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Structures and Algorithms in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what_is_dsa/what_is_dsa.html"><strong aria-hidden="true">1.</strong> What is DSA?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what_is_dsa/data_structures.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="what_is_dsa/algorithms.html"><strong aria-hidden="true">1.2.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="array/array.html"><strong aria-hidden="true">2.</strong> Array</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="array/primitive.html"><strong aria-hidden="true">2.1.</strong> Primitive Type</a></li><li class="chapter-item expanded "><a href="array/vector.html"><strong aria-hidden="true">2.2.</strong> Vector Type</a></li></ol></li><li class="chapter-item expanded "><a href="2_stack.html"><strong aria-hidden="true">3.</strong> Stack</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithms in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-data-structures-and-algorithms"><a class="header" href="#what-is-data-structures-and-algorithms">What is Data Structures and Algorithms</a></h1>
<p>Data Structures and Algorithms are closely connected, like space and time. A data structure is like a space where many things exist and can move freely. This space has planets, stars, galaxies, and more. Some things move in a predictable way, while others don't.
But without time, these things don't matter. Nothing happens, and nothing changes.</p>
<p>It's the same with data structures and algorithms. Without algorithms, data is useless, and without data structures, algorithms can't work.
We use algorithms to create, access, update, and delete data structures.</p>
<p>In short, data structures and algorithms are like two sides of the same coin. One can't exist without the other.</p>
<p>Let's explore the technical details of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h1>
<p>A data structure is like a blueprint that shows how data is connected and organized.</p>
<p>To understand this better, let's look at a common data structure called an array.</p>
<p>An <strong>Array</strong> is a group of similar things. It's a data structure because it helps us see how data is arranged in memory and how they relate to each other.</p>
<p>A more formal definition of a data structure is:
'<strong>Data structure</strong> is a special way of organizing, processing, finding, changing, and storing data. Data structures are like plans for organizing data to meet specific needs. They don't just store data, they also keep track of how the data is connected.'<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<h2 id="operations-on-data-structures"><a class="header" href="#operations-on-data-structures">Operations on Data Structures</a></h2>
<p>Arrays are a fundamental data structure that requires various operations to function effectively. These operations include:</p>
<ol>
<li><strong>Traversal</strong>: This involves accessing each element of an array in a sequential order, either from start to end or vice versa.</li>
<li><strong>Insertion</strong>: This is the process of adding a new element to an array. The new element can be inserted at the beginning, end, or any other position within the array, depending on the application. Existing elements may shift to accommodate the new element.</li>
<li><strong>Deletion</strong>: This operation involves removing an existing element from an array. Similar to insertion, an element can be deleted from any position within the array, and existing elements may shift to fill the gap.</li>
<li><strong>Search</strong>: This process involves finding a specific element within an array by comparing the target element with each element in the array until a match is found.</li>
<li><strong>Sorting</strong>: This operation involves arranging elements in a specific order.</li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.altexsoft.com/blog/data-structure/">Data Structure - altexsoft.com</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>An array is a collection  of similar data types which are stored in contiguous memory locations. Each location has an index number through which we can access the element of that particular index.
In programming, we have to use data elements of similar type and similar purpose. Instead of declaring and defining every variable individually, we can use an array to store all of them together.</p>
<p>In Rust an array can be defined in two methods. Each method comes with its pros and cons. The two types of array in rust are:</p>
<h2 id="vector-type"><a class="header" href="#vector-type">Vector type</a></h2>
<p>Unlike arrays, a vector stores the size of the array as well. Arrays don't need to store its size. That is why we can access an array element even when we exceed the actual capacity. The boundaries are not defined.
Another thing about vectors is they're generally stored in a heap and they have a large size allocated than being used</p>
<p>As arrays and vectors, both copy items into another larger array / vector once more element(s) are added, vectors do the copying less often as they already have more capacity than the actual length.</p>
<p>"A vector is a contiguous growable array type with heap allocated contents".</p>
<p>Capacity of a vector: The amount of space allocated for any further elements to be added onto the vector.
Length of a vector: The number of actual element present the vector.</p>
<blockquote>
<p>NOTE: <br>
If length is greater than capacity (length &gt; capacity) the vector is reallocated.</p>
</blockquote>
<h2 id="array-or-vector"><a class="header" href="#array-or-vector">Array or Vector?</a></h2>
<p>In most cases, vectors are considered better than arrays for a few key reasons:</p>
<ul>
<li><strong>Size flexibility:</strong> Vectors are dynamic, meaning their size can grow or shrink as needed during program execution. Arrays have a fixed size defined at the time of creation, which can lead to problems if you don't know exactly how many elements you'll need beforehand.</li>
<li><strong>Memory management:</strong> Vectors handle memory allocation and deallocation automatically. Arrays require manual memory management, which can be error-prone and lead to memory leaks.</li>
<li><strong>Built-in functionality:</strong> Vectors often come with additional features like methods for sorting, searching, and element insertion/deletion at specific positions. Arrays typically require manual implementation for these operations.</li>
</ul>
<p>However, there are some situations where arrays might be preferable:</p>
<ul>
<li><strong>Performance:</strong> For fixed-size data sets, arrays can be slightly faster than vectors due to their simpler structure and lack of overhead for managing size changes.</li>
<li><strong>Memory usage:</strong> If you know the exact size you need upfront and memory usage is a critical concern, arrays can be a more memory-efficient choice.</li>
</ul>
<p>Keeping this in mind, let's look at some of the algorithms that go hand in hand with arrays</p>
<h2 id="array-algorithms"><a class="header" href="#array-algorithms">Array Algorithms</a></h2>
<h3 id="search-algorithms-"><a class="header" href="#search-algorithms-">Search Algorithms üîç</a></h3>
<p>They serve the function of checking and retrieving information stored within some data structure where that data is stored.</p>
<h4 id="1-linear-search-algorithm"><a class="header" href="#1-linear-search-algorithm">1. Linear Search algorithm</a></h4>
<p>It is also called sequential search algorithm. This algorithm works by sequentially iterating through the whole array from one end until the target element is round. If found, the algorithm returns its index, else - 1.</p>
<h4 id="2-binary-search-algorithm"><a class="header" href="#2-binary-search-algorithm">2. Binary Search Algorithm</a></h4>
<p>This type of searching algorithm is used to find the position of a specific value contained in a sorted array. The binary search algorithm works on the principle of divide and conquer and is the best searching algorithm because its faster to run.</p>
<h3 id="sorting-algorithms-"><a class="header" href="#sorting-algorithms-">Sorting Algorithms üß≤</a></h3>
<p>Sorting algorithm rearrange a given array of elements in a specific order. In case of numbers, it could be ascending or descending order.</p>
<ol>
<li>Bubble Sort: It is the simplest sorting algorithm, where is iteratively swaps the adjacent algorithms if they are in the wrong order.</li>
<li>Selection Sort: This algorithm works by iteratively selecting the smallest / largest element from the unsorted portion of the list and moving it to the sorted portion of the array.</li>
<li>Insertion sort: This sorting algorithm works by iteratively inserting each element of an unsorted array into its correct position in a sorted portion of the list.</li>
<li>Merge sort: It is a sorting algorithm that follows the <em>divide and conquer</em> strategy. It works by iteratively dividing the input array into smaller subarrays and sorting those subarrays, then merging them back together to obtain the sorted array.</li>
<li>Quick sort: It is a sorting algorithm that implements the divide and conquer strategy and picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-type"><a class="header" href="#primitive-type">Primitive type</a></h1>
<p>In rust primitive data types are those, which are built in and do not need any library to be used. Rust provides this type of array.</p>
<h2 id="initializing-an-array"><a class="header" href="#initializing-an-array">Initializing an array</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // default type is i32
    let arr = [1, 2, 3, 4, 5];
    println!("Array: {:?}", arr);
<span class="boring">}</span></code></pre></pre>
<h2 id="defining-an-array"><a class="header" href="#defining-an-array">Defining an array</a></h2>
<p>We can specify type and length in the format of <code>[T; N]</code>, where:<br>
<code>T</code>: Element Type<br>
<code>N</code>: Size (it is constant and it should be non-negative)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // name: [T ; N] = [...
    let arr: [u8; 3] = [0, 3, 5]; 
    println!("Array: {:?}", arr);
<span class="boring">}</span></code></pre></pre>
<p>We can also repeat values by specifying a value to repeat and the number of times to repeat it<br>
<code>[E; N]</code><br>
<code>E</code>: Expression<br>
<code>N</code>: Number of times to repeat</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // name: [T ; N] = [E; N];
    let arr: [u8; 4] = [9; 4]; 
    println!("Array: {:?}", arr); 
<span class="boring">}</span></code></pre></pre>
<h2 id="modifying-an-array"><a class="header" href="#modifying-an-array">Modifying an array</a></h2>
<p>We can modify the values using the index of the element provided the array is mutable.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Advantages</strong></th><th><strong>Disadvantages</strong></th></tr></thead><tbody>
<tr><td>Accessing / searching for elements is fast.</td><td>Fixed size</td></tr>
<tr><td>Can represent multiple elements using single name.</td><td>Memory wastage</td></tr>
<tr><td>Traversal is easy</td><td>Insertion and deletion is difficult</td></tr>
<tr><td>Continuous memory allocation</td><td>Sorting is difficult</td></tr>
</tbody></table>
</div>
<h2 id="types-of-array"><a class="header" href="#types-of-array">Types of Array:</a></h2>
<h3 id="1-1d-array"><a class="header" href="#1-1d-array">1. 1D array:</a></h3>
<p>One dimensional array refers to an array that contains only a row of elements. A 1D array can be accessed by using a single index.</p>
<p><strong>Initializing a 1D array</strong>: Arrays are one dimensional by default. When you initialize an array, like you did <a href="array/primitive.html#initializing-an-array">at the start</a>, you are initializing a 1D array.</p>
<p><strong>Use Case</strong>: 1D arrays are used when we have to store similar items contiguously. These items are related in some way.</p>
<h3 id="2d-array"><a class="header" href="#2d-array">2D array:</a></h3>
<p>Two Dimensional array refers to an array that contains rows as well as columns of element. A 2D array can be accessed by using two indices; one index specifying the row, the other specifying the column.</p>
<p><strong>Initializing a 2D array</strong>: While arrays are stored in a single line, they are ideal for a One dimensional relationship. But in some cases you need to store elements that have a Two dimensional relationship. To structure that data in such a way, this is how we do it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    const ROWS: usize = 4;
    const COLS: usize = 5;

    // name: [[ T;    C];    R]
    let arr: [[u8; COLS]; ROWS] = [[1; COLS]; ROWS];
    println!("Array: {:?}", arr); 
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="stack"><a class="header" href="#stack">Stack</a></h1>
<p>A stack is a linear data structure that follows the principle of <em>Last In First Out (LIFO)</em>. This means that the last element inserted inside the stack is removed first.
e.g.
Imagine you have a can of /////</p>
<p>Types:?</p>
<h3 id="operations-on-a-stack"><a class="header" href="#operations-on-a-stack">Operations on a Stack</a></h3>
<ol>
<li>push: Add an element to the top of a stack.</li>
<li>pop: Remove an element from the top of a stack.</li>
<li>is_empty: check if stack is empty</li>
<li>is_full: check if stack is full</li>
<li>peek: get value without removing from the stack</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
